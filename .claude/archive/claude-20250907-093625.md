# Claude.md: TDD-Centric Next.js Web App with Claude Code Subagents

A comprehensive guide for building modern web applications using Test-Driven Development principles with Next.js, optimized for Claude Code subagent orchestration and current best practices.

## Project philosophy and approach

This project embraces **AI-Enhanced Test-Driven Development** with Next.js and Claude Code subagents, combining the proven discipline of TDD with specialized AI assistants for different development phases. The approach prioritizes fast feedback loops, maintainable code architecture, and comprehensive quality assurance through subagent orchestration.

**Core principles:**
- **Tests define requirements** - Write comprehensive tests first to guide both human and subagent implementation
- **Subagent specialization** - Use specialized AI assistants for testing, implementation, security, performance, and code review
- **Server-first architecture** - Leverage Next.js Server Components for optimal performance and SEO
- **Orchestrated workflow** - Coordinate subagents through structured TDD phases
- **Documentation as context** - Maintain living documentation that serves both humans and AI subagents

## Technology stack

### Next.js + PostgreSQL + shadcn/ui

**Frontend framework**
**Next.js 14+ + TypeScript + shadcn/ui**
- **Next.js App Router**: Server Components, automatic optimizations, superior SEO
- **shadcn/ui**: Copy-paste component library with excellent subagent compatibility
- **TypeScript**: Type safety with exceptional Claude Code integration
- **Tailwind CSS**: Utility-first styling with consistent design tokens

**Backend strategy**
**Next.js API Routes + PostgreSQL + Prisma**
- **API Routes**: Co-located with frontend for rapid development and easy testing
- **PostgreSQL**: Production-grade database with excellent testing tools  
- **Prisma**: Type-safe ORM with superior subagent integration
- **Server Actions**: For mutations and form handling with built-in validation

**Testing framework**
**Vitest + Playwright + React Testing Library + MSW**
- **Vitest**: 3x faster than Jest for TypeScript, zero configuration, excellent Next.js integration
- **Playwright**: Cross-browser E2E testing with Next.js App Router support
- **React Testing Library**: Component testing focused on user behavior, works with Server Components
- **MSW (Mock Service Worker)**: API mocking for both browser and Node.js environments

**Database strategy**
**PostgreSQL + Neon + Prisma**
- **PostgreSQL**: Most popular database (49% usage), excellent ACID compliance, robust testing tools
- **Neon**: Serverless PostgreSQL with database branching for isolated test environments
- **Prisma**: Type-safe ORM with excellent migration tools and subagent integration

**Infrastructure and deployment**
**Vercel + Neon PostgreSQL**
- **Vercel**: Optimized for Next.js with automatic deployments, edge functions, and preview deployments
- **Neon**: Serverless PostgreSQL with database branching for testing environments

**Package management**
**pnpm**
- 70% disk space savings vs npm, strict dependency resolution prevents phantom dependencies
- Excellent monorepo support for potential future service extraction

**AI development tools**
**Cursor + Claude Code + Subagents**
- **Cursor**: AI-first IDE with superior context management and Next.js project understanding
- **Claude Code**: Advanced reasoning capabilities with subagent orchestration for specialized tasks
- **Subagents**: Specialized AI assistants for different aspects of TDD workflow (testing, implementation, review)
- **Integration**: Native terminal access for running tests, database migrations, and Next.js commands

## Project structure with subagents

```
project-root/
â”œâ”€â”€ .cursorrules                 # Claude Code behavior configuration
â”œâ”€â”€ .claude/                    # Claude Code subagent configurations
â”‚   â”œâ”€â”€ subagents/
â”‚   â”‚   â”œâ”€â”€ test-architect.md   # Test design and strategy specialist
â”‚   â”‚   â”œâ”€â”€ nextjs-dev.md      # Next.js implementation specialist
â”‚   â”‚   â”œâ”€â”€ security-auditor.md # Security and compliance reviewer
â”‚   â”‚   â”œâ”€â”€ performance-optimizer.md # Performance analysis specialist
â”‚   â”‚   â””â”€â”€ code-reviewer.md   # Code quality and patterns reviewer
â”œâ”€â”€ .github/workflows/          # CI/CD automation
â”œâ”€â”€ docs/                       # Living documentation for Claude context
â”‚   â”œâ”€â”€ architecture.mermaid    # System design diagrams
â”‚   â”œâ”€â”€ technical.md            # Implementation specifications  
â”‚   â”œâ”€â”€ api-specs/              # OpenAPI specifications
â”‚   â””â”€â”€ decisions/              # Architectural Decision Records
â”œâ”€â”€ tasks/
â”‚   â”œâ”€â”€ todo.md                # Active to-do list with timestamps and subagent assignments
â”‚   â””â”€â”€ tasks.md               # Development task breakdown
â”œâ”€â”€ logs/
â”‚   â””â”€â”€ prompts.md             # Log of all user prompts with timestamps
â”œâ”€â”€ prisma/
â”‚   â”œâ”€â”€ schema.prisma          # Database schema
â”‚   â”œâ”€â”€ migrations/            # Database migrations
â”‚   â””â”€â”€ seed.ts               # Database seeding
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/                   # Next.js App Router
â”‚   â”‚   â”œâ”€â”€ (auth)/           # Route groups
â”‚   â”‚   â”œâ”€â”€ api/              # API routes
â”‚   â”‚   â”œâ”€â”€ globals.css       # Global styles
â”‚   â”‚   â”œâ”€â”€ layout.tsx        # Root layout
â”‚   â”‚   â””â”€â”€ page.tsx          # Home page
â”‚   â”œâ”€â”€ components/            # Reusable UI components
â”‚   â”‚   â”œâ”€â”€ ui/               # shadcn/ui components
â”‚   â”‚   â”œâ”€â”€ forms/            # Form components
â”‚   â”‚   â””â”€â”€ layout/           # Layout components
â”‚   â”œâ”€â”€ lib/                  # Utility libraries
â”‚   â”‚   â”œâ”€â”€ db.ts            # Database connection
â”‚   â”‚   â”œâ”€â”€ auth.ts          # Authentication logic
â”‚   â”‚   â”œâ”€â”€ utils.ts         # Utility functions
â”‚   â”‚   â””â”€â”€ validations.ts   # Zod schemas
â”‚   â””â”€â”€ types/                # TypeScript definitions
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __fixtures__/         # Test data and fixtures
â”‚   â”œâ”€â”€ __mocks__/           # Mock implementations
â”‚   â”œâ”€â”€ unit/                # Isolated unit tests
â”‚   â”œâ”€â”€ integration/         # API and component integration tests
â”‚   â”œâ”€â”€ e2e/                 # End-to-end scenarios
â”‚   â””â”€â”€ support/             # Test utilities
â””â”€â”€ public/                   # Static assets
```

## Claude Code subagent definitions

### Subagent architecture
Six specialized subagents work together to ensure comprehensive coverage of all development aspects in the design-first TDD workflow, with meta-optimization for maximum efficiency.

### Subagent definitions
The detailed specifications for each subagent are maintained in separate files:

- **[Prompting Expert](.claude/subagents/prompting-expert.md)** - Meta-specialist in Claude Code prompt optimization, model selection, and subagent orchestration strategy
- **[UI Designer](.claude/subagents/ui-designer.md)** - Specialist in interface design, design systems, and creating accessible, responsive user interfaces
- **[Next.js Developer](.claude/subagents/nextjs-dev.md)** - Specialist in Next.js 14+ App Router implementation, Server Components, Client Components, and API routes
- **[Security Auditor](.claude/subagents/security-auditor.md)** - Specialist in security review, vulnerability assessment, and compliance validation
- **[Performance Optimizer](.claude/subagents/performance-optimizer.md)** - Specialist in Next.js performance optimization and Core Web Vitals improvement
- **[Code Reviewer](.claude/subagents/code-reviewer.md)** - Specialist in code quality review, architectural consistency, and best practices validation

## TDD workflow with subagent orchestration

### Enhanced Red-Green-Blue-Refactor cycle

**Red Phase (Test Design)**:
1. Use `@test-architect` to analyze requirements and design comprehensive test suites
2. Generate test specifications covering unit, integration, and E2E scenarios
3. Create test data fixtures and mock strategies
4. Validate test coverage meets quality standards

```typescript
// Example: Authentication test suite designed by Test Architect
describe('User Authentication System', () => {
  describe('POST /api/auth/login', () => {
    describe('when credentials are valid', () => {
      it('should return JWT token and user data', async () => {
        const mockUser = { email: 'user@example.com', id: '1' };
        vi.mocked(validateCredentials).mockResolvedValue(mockUser);
        
        const response = await POST(new Request('http://localhost/api/auth/login', {
          method: 'POST',
          body: JSON.stringify({ email: 'user@example.com', password: 'password123' })
        }));
        
        const data = await response.json();
        expect(response.status).toBe(200);
        expect(data.user).toEqual(mockUser);
        expect(data.token).toBeDefined();
      });
    });
    
    describe('when credentials are invalid', () => {
      it('should return 401 with error message', async () => {
        vi.mocked(validateCredentials).mockRejectedValue(new Error('Invalid credentials'));
        
        const response = await POST(new Request('http://localhost/api/auth/login', {
          method: 'POST',
          body: JSON.stringify({ email: 'user@example.com', password: 'wrong' })
        }));
        
        expect(response.status).toBe(401);
      });
    });
  });
  
  describe('LoginForm Client Component', () => {
    it('should handle form submission and redirect on success', async () => {
      const mockSubmit = vi.fn().mockResolvedValue({ success: true });
      render(<LoginForm onSubmit={mockSubmit} />);
      
      await user.type(screen.getByLabelText(/email/i), 'user@example.com');
      await user.type(screen.getByLabelText(/password/i), 'password123');
      await user.click(screen.getByRole('button', { name: /sign in/i }));
      
      expect(mockSubmit).toHaveBeenCalledWith({
        email: 'user@example.com',
        password: 'password123'
      });
    });
  });
});
```

**Green Phase (Implementation)**:
1. Use `@nextjs-dev` to implement code following test specifications
2. Ensure Next.js best practices and patterns
3. Implement Server/Client Components appropriately
4. Follow TypeScript strict mode compliance

```typescript
// Example: Implementation by Next.js Developer
/*
Business Context: User authentication for SaaS application
Security Requirements: JWT tokens, bcrypt password hashing, rate limiting
Architecture: Next.js App Router with Server Actions for mutations
Database: PostgreSQL with Prisma ORM
*/

export async function POST(request: Request) {
  try {
    const { email, password } = await request.json();
    
    // Validate input with Zod schema
    const validatedData = loginSchema.parse({ email, password });
    
    // Authenticate user with bcrypt
    const user = await validateCredentials(validatedData.email, validatedData.password);
    
    // Generate JWT token
    const token = await generateJWT({ userId: user.id });
    
    return NextResponse.json({ user, token });
  } catch (error) {
    if (error instanceof ZodError) {
      return NextResponse.json({ error: 'Invalid input' }, { status: 400 });
    }
    if (error instanceof AuthenticationError) {
      return NextResponse.json({ error: 'Authentication failed' }, { status: 401 });
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

**Blue Phase (Security & Performance)**:
1. Use `@security-auditor` to review implementation for vulnerabilities
2. Use `@performance-optimizer` to analyze and optimize performance
3. Address security findings and performance bottlenecks
4. Validate compliance with security standards

**Refactor Phase (Quality Assurance)**:
1. Use `@code-reviewer` for comprehensive code quality review
2. Address architectural inconsistencies and technical debt
3. Ensure maintainability and scalability
4. Update documentation and architectural decisions

## Subagent orchestration commands

### Development workflow commands

```bash
# Phase 1: Test Design
cursor chat "@test-architect design comprehensive test suite for user authentication feature with email/password login, JWT tokens, and proper error handling"

# Phase 2: Implementation  
cursor chat "@nextjs-dev implement user authentication following the test specifications with Server Components, API routes, and Client Components"

# Phase 3: Security Review
cursor chat "@security-auditor audit the authentication implementation for security vulnerabilities, proper input validation, and OWASP compliance"

# Phase 4: Performance Optimization
cursor chat "@performance-optimizer analyze authentication flow performance, optimize Core Web Vitals, and recommend caching strategies"

# Phase 5: Code Quality Review
cursor chat "@code-reviewer review authentication implementation for code quality, architectural consistency, and refactoring opportunities"

# Cross-cutting concerns
cursor chat "@test-architect @security-auditor collaborate on security testing strategy for authentication endpoints"

cursor chat "@nextjs-dev @performance-optimizer implement performance-optimized Server Components with proper caching"
```

### Subagent collaboration patterns

**Test-driven security review**:
```bash
cursor chat "@test-architect design security test cases for SQL injection, XSS, and CSRF protection"
cursor chat "@security-auditor review test cases and add additional security scenarios"
cursor chat "@nextjs-dev implement security measures to pass all security tests"
```

**Performance-aware implementation**:
```bash
cursor chat "@performance-optimizer define performance requirements and optimization targets"
cursor chat "@nextjs-dev implement features with performance constraints and Core Web Vitals optimization"
cursor chat "@performance-optimizer validate implementation meets performance targets"
```

## Testing hierarchy and strategy

### Testing pyramid for Next.js applications
Following modern testing best practices optimized for Next.js App Router and subagent workflow:

- **Static Analysis (Foundation)**: ESLint, TypeScript, Prettier with Next.js rules
- **Unit Tests (25%)**: Pure functions, utility methods, isolated business logic
- **Integration Tests (60%)**: Server Components, API routes, Client Component interactions
- **End-to-End Tests (15%)**: Critical user journeys with Next.js routing and Server Actions

### Test organization with subagents

**Unit tests (Test Architect designed)**:
```typescript
// src/lib/utils.test.ts
import { formatCurrency } from './utils';

describe('formatCurrency utility', () => {
  describe('when formatting USD currency', () => {
    it('should format positive amounts correctly', () => {
      expect(formatCurrency(1234.56, 'USD')).toBe('$1,234.56');
    });
    
    it('should handle zero amounts', () => {
      expect(formatCurrency(0, 'USD')).toBe('$0.00');
    });
    
    it('should handle negative amounts', () => {
      expect(formatCurrency(-1234.56, 'USD')).toBe('-$1,234.56');
    });
  });
  
  describe('when formatting EUR currency', () => {
    it('should format with Euro symbol', () => {
      expect(formatCurrency(1234.56, 'EUR')).toBe('â‚¬1,234.56');
    });
  });
});
```

**Integration tests (Next.js Developer implemented)**:
```typescript
// tests/integration/api/auth.test.ts
import { POST } from '@/app/api/auth/login/route';
import { prismaMock } from '../__mocks__/prisma';

describe('Authentication API Integration', () => {
  describe('POST /api/auth/login', () => {
    it('successfully authenticates user with valid credentials', async () => {
      const mockUser = { 
        id: '1', 
        email: 'user@example.com', 
        hashedPassword: await bcrypt.hash('password123', 10)
      };
      prismaMock.user.findUnique.mockResolvedValue(mockUser);
      
      const request = new Request('http://localhost/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: 'user@example.com', password: 'password123' })
      });
      
      const response = await POST(request);
      const data = await response.json();
      
      expect(response.status).toBe(200);
      expect(data.user.email).toBe('user@example.com');
      expect(data.token).toBeDefined();
      expect(jwt.verify(data.token, process.env.JWT_SECRET)).toBeTruthy();
    });
  });
});
```

## CI/CD practices with subagent validation

### GitHub Actions workflow
```yaml
name: Next.js TDD with Subagent Validation
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20]
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'pnpm'
          
      - run: pnpm install --frozen-lockfile
      
      - name: Generate Prisma client
        run: pnpm db:generate
        
      - name: Run unit tests (Test Architect designed)
        run: pnpm test:unit --coverage
        
      - name: Run integration tests (Next.js Developer implemented)  
        run: pnpm test:integration
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/test
          
      - name: Security audit (Security Auditor standards)
        run: pnpm audit --audit-level moderate
        
      - name: Performance budget check (Performance Optimizer targets)
        run: pnpm run performance-budget-check
        
      - name: Build Next.js application
        run: pnpm build
        
      - name: Code quality validation (Code Reviewer standards)
        run: pnpm run quality-check
        
      - name: Run E2E tests
        run: pnpm test:e2e
        if: github.event_name == 'pull_request'
        
      - uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info

  subagent-validation:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Validate subagent standards compliance
        run: |
          # Validate Test Architect test coverage standards
          pnpm run validate:test-coverage
          
          # Validate Security Auditor security patterns
          pnpm run validate:security-patterns
          
          # Validate Performance Optimizer metrics
          pnpm run validate:performance-metrics
          
          # Validate Code Reviewer quality standards
          pnpm run validate:code-quality
```

## Configuration files

### .cursorrules (Claude Code with Subagents)
```markdown
# Project Context and Architecture
SYSTEM_CONTEXT: |
Required file reads on startup:
- docs/architecture.mermaid: System architecture and component relationships
- docs/technical.md: Technical specifications and patterns  
- tasks/tasks.md: Current development tasks and requirements
- tasks/todo.md: Active to-do list with timestamps and subagent assignments
- logs/prompts.md: User prompt history for context preservation
- docs/status.md: Project progress and state
- prisma/schema.prisma: Database schema and relationships
- .claude/subagents/*.md: Subagent definitions and responsibilities

# Subagent Orchestration Rules
SUBAGENT_WORKFLOW: |
1. Use @test-architect for comprehensive test design and strategy
2. Use @nextjs-dev for implementation following test specifications
3. Use @security-auditor for security review and vulnerability assessment
4. Use @performance-optimizer for performance analysis and optimization
5. Use @code-reviewer for code quality and architectural consistency
6. Coordinate subagents for cross-cutting concerns and collaboration
7. Follow Red-Green-Blue-Refactor cycle with appropriate subagent phases

# TDD Workflow Rules
DEVELOPMENT_APPROACH: |
0. USE @prompting-expert for COMPLEX tasks only (multi-step workflows, multiple subagents, architectural changes, new features)
1. LOG user prompt in logs/prompts.md with timestamp and context
2. CREATE corresponding to-do entries in tasks/todo.md with subagent assignments 
3. ALWAYS use @ui-designer for design specifications before implementation
4. USE @test-architect to design tests following design specifications
5. CREATE comprehensive test suites covering unit, integration, and E2E scenarios
6. IMPLEMENT with @nextjs-dev following design and test specifications
7. REVIEW with @security-auditor and @performance-optimizer
8. VALIDATE with @code-reviewer for quality and consistency
9. UPDATE task completion timestamps, costs, and docs/status.md with progress

# Prompting Expert Usage Guidelines
OPTIMIZATION_TRIGGERS: |
Use @prompting-expert when:
- Multiple subagents needed (3+ specialists)
- Multi-step workflows spanning days/weeks
- Architectural or design system changes
- New feature implementation
- Complex refactoring tasks
- Budget-sensitive operations
- First-time similar task patterns

Skip @prompting-expert for:
- Single file edits or fixes
- Simple explanations or documentation
- Quick debugging or logging additions
- Familiar, repetitive tasks
- Urgent hotfixes
- Clear, well-defined single-step tasks

# Tech Stack Guidelines
TECHNOLOGY_CONSTRAINTS: |
- Next.js 14+ App Router with TypeScript
- shadcn/ui components for UI elements
- Tailwind CSS for styling
- Prisma for database operations
- Zod for runtime validation
- Vitest + Playwright for testing
- MSW for API mocking

# Subagent Quality Standards
QUALITY_REQUIREMENTS: |
- Test Architect: 80%+ coverage, comprehensive edge cases
- Next.js Developer: TypeScript strict mode, proper Server/Client separation
- Security Auditor: OWASP compliance, input validation, secure patterns
- Performance Optimizer: Core Web Vitals "Good" ratings, <250KB bundles
- Code Reviewer: Clean code principles, architectural consistency
```

### package.json scripts (with subagent validation)
```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "test": "vitest",
    "test:unit": "vitest run tests/unit",
    "test:integration": "vitest run tests/integration",
    "test:e2e": "playwright test",
    "test:watch": "vitest --watch",
    "test:coverage": "vitest --coverage",
    "test:ui": "vitest --ui",
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:migrate": "prisma migrate deploy",
    "db:seed": "tsx prisma/seed.ts",
    "db:studio": "prisma studio",
    "lint": "next lint",
    "format": "prettier --write src",
    "type-check": "tsc --noEmit",
    "validate:test-coverage": "node scripts/validate-test-coverage.js",
    "validate:security-patterns": "node scripts/validate-security.js",
    "validate:performance-metrics": "node scripts/validate-performance.js",
    "validate:code-quality": "node scripts/validate-quality.js",
    "performance-budget-check": "node scripts/performance-budget.js",
    "quality-check": "npm-run-all lint type-check validate:code-quality",
    "subagent:test-architect": "echo 'Use: cursor chat @test-architect [prompt]'",
    "subagent:nextjs-dev": "echo 'Use: cursor chat @nextjs-dev [prompt]'",
    "subagent:security-auditor": "echo 'Use: cursor chat @security-auditor [prompt]'",
    "subagent:performance-optimizer": "echo 'Use: cursor chat @performance-optimizer [prompt]'",
    "subagent:code-reviewer": "echo 'Use: cursor chat @code-reviewer [prompt]'",
    "pre-commit": "lint-staged"
  }
}
```

## Getting started with subagents

### Project initialization
```bash
# Create Next.js project with TypeScript
npx create-next-app@latest my-tdd-app --typescript --tailwind --eslint --app --src-dir

# Navigate to project
cd my-tdd-app

# Install additional dependencies
pnpm add @prisma/client prisma zod @hookform/react-hook-form @radix-ui/react-slot class-variance-authority clsx lucide-react tailwind-merge

# Install dev dependencies
pnpm add -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom @vitejs/plugin-react playwright @playwright/test msw

# Create subagent directory and definitions
mkdir -p .claude/subagents

# Copy subagent definitions (from this guide)
# Set up testing configuration
touch vitest.config.ts playwright.config.ts tests/setup.ts

# Initialize Prisma and shadcn/ui
npx prisma init
npx shadcn-ui@latest init
```

### First feature with subagents
1. **Design tests**: `cursor chat "@test-architect design comprehensive test suite for user registration with email validation, password requirements, and database persistence"`

2. **Implement feature**: `cursor chat "@nextjs-dev implement user registration following test specifications with Server Actions, Zod validation, and Prisma integration"`

3. **Security review**: `cursor chat "@security-auditor audit user registration for password security, input validation, and potential vulnerabilities"`

4. **Performance optimization**: `cursor chat "@performance-optimizer analyze registration flow performance and optimize for Core Web Vitals"`

5. **Code quality review**: `cursor chat "@code-reviewer review registration implementation for code quality, patterns, and maintainability"`

6. **Deploy**: Push to Vercel with automated subagent validation pipeline

### Environment setup
```env
# .env.local
DATABASE_URL="postgresql://username:password@localhost:5432/myapp"
NEXTAUTH_SECRET="your-secret-key"
NEXTAUTH_URL="http://localhost:3000"
```

### Subagent workflow examples

**Feature development workflow**:
```bash
# Phase 1: Requirements and Test Design
cursor chat "@test-architect analyze user story: 'As a user, I want to register with email and password so I can access the platform' and design comprehensive test suite"

# Phase 2: Implementation
cursor chat "@nextjs-dev implement user registration with the following test requirements: [paste test specifications from Test Architect]"

# Phase 3: Security and Performance Review
cursor chat "@security-auditor @performance-optimizer collaborate to review registration implementation for security vulnerabilities and performance optimization opportunities"

# Phase 4: Quality Assurance
cursor chat "@code-reviewer conduct final review of registration feature for code quality, architectural consistency, and documentation completeness"
```

**Cross-cutting collaboration**:
```bash
# Security-focused testing
cursor chat "@test-architect @security-auditor design security test cases for authentication system including penetration testing scenarios"

# Performance-aware implementation
cursor chat "@nextjs-dev @performance-optimizer implement user dashboard with server-side rendering optimization and efficient data fetching patterns"

# Comprehensive feature review
cursor chat "@security-auditor @performance-optimizer @code-reviewer conduct comprehensive review of user management system for security, performance, and code quality"
```

## Task Management and Logging

### To-Do List Management
Maintain an active to-do list in `tasks/todo.md` to track all development tasks with timestamps and subagent assignments.

**To-Do Entry Format:**
```markdown
## [YYYY-MM-DD HH:MM] - Task Title
- **Status**: Pending/In Progress/Completed
- **Assigned Subagent(s)**: @ui-designer, @nextjs-dev, etc.
- **Created**: YYYY-MM-DD HH:MM:SS
- **Completed**: YYYY-MM-DD HH:MM:SS (when finished)
- **Description**: Detailed task description
- **Dependencies**: Other tasks this depends on
- **Acceptance Criteria**: 
  - [ ] Criterion 1
  - [ ] Criterion 2

### Implementation Notes
- Implementation details
- Challenges encountered
- Solution approach

---
```

**To-Do Management Commands:**
```bash
# Create new task entry
echo "## [$(date '+%Y-%m-%d %H:%M')] - [Task Title]" >> tasks/todo.md

# Update task status to completed
# Add completion timestamp and mark as completed
```

### Prompt Logging
Maintain a comprehensive log of all user prompts in `logs/prompts.md` for context preservation and workflow analysis.

**Standard Prompt Log Entry Format:**
```markdown
## [YYYY-MM-DD HH:MM:SS] - User Prompt
**Context**: Current development phase/feature being worked on
**Original Prompt**: 
```
[Exact user prompt text]
```

**Subagents Involved**: @subagent1, @subagent2
**Response Summary**: Brief summary of actions taken
**Files Modified**: List of files created/modified
**Follow-up Actions**: Any pending tasks or next steps

---
```

**Optimized Prompt Log Entry Format (when using @prompting-expert):**
```markdown
## [YYYY-MM-DD HH:MM:SS] - User Prompt (OPTIMIZED)
**Context**: Current development phase/feature being worked on
**Original Prompt**: 
```
[Exact user prompt text]
```

**ðŸ”§ PROMPTING EXPERT ANALYSIS**:
- **Complexity**: [Simple/Moderate/Complex/Expert-level]
- **Model Recommended**: [Haiku/Sonnet/Opus]
- **Cost Estimate**: [Token count and pricing]
- **Context Files**: [Essential files identified]
- **Subagent Strategy**: [Recommended collaboration pattern]

**Optimized Prompt**: 
```
[Restructured and enhanced prompt from @prompting-expert]
```

**Optimization Benefits**:
- Token savings: [X% reduction]
- Execution strategy: [Parallel/Sequential workflow]
- Expected time savings: [Estimated improvement]

**Subagents Involved**: @prompting-expert + [@actual-execution-subagents]
**Response Summary**: Brief summary of actions taken
**Files Modified**: List of files created/modified
**Follow-up Actions**: Any pending tasks or next steps

---
```

### Workflow Integration
1. **Optimize prompt first** (for complex tasks): Use @prompting-expert to analyze and optimize
2. **Log the user prompt**: Record original version and optimization analysis in `logs/prompts.md` with clear before/after comparison
3. **Create corresponding to-do entries**: Break down requests into manageable tasks
4. **Select optimal model**: Follow prompting expert recommendations for cost-effectiveness
5. **Assign subagents**: Specify responsibilities based on optimization analysis
6. **Execute in parallel**: Use recommended concurrent execution patterns where possible
7. **Track progress**: Update task status and timestamps throughout development
8. **Document completion**: Record completion time, costs, optimization benefits, and lessons learned

### Meta-Optimization Workflow (Conditional)
**For complex development tasks (3+ subagents, multi-step workflows, new features):**
```bash
# Optional Step 0: Prompt Optimization (when complexity warrants it)
cursor chat "@prompting-expert optimize this development request: '[original prompt]' - analyze complexity, recommend model tier, identify essential context, and design subagent collaboration pattern"

# Then execute optimized workflow using recommendations
```

**For cost-sensitive operations:**
```bash
cursor chat "@prompting-expert recommend most cost-effective approach for [specific task] while maintaining quality standards"
```

**For complex multi-phase projects:**
```bash
cursor chat "@prompting-expert design optimal subagent orchestration workflow for [feature description] with parallel execution opportunities"
```

### Quick Decision Guide: When to Use Prompting Expert

**âœ… Use @prompting-expert for:**
- "Build user authentication system with JWT tokens"
- "Implement e-commerce checkout flow with payment processing"  
- "Refactor database layer to support multi-tenancy"
- "Create design system with accessibility compliance"
- "Set up CI/CD pipeline with testing and deployment"

**âŒ Skip @prompting-expert for:**
- "Fix typo in button text"
- "Add console.log to debug function"
- "Explain what this component does"
- "Change button color to blue"
- "Add missing semicolon"

**ðŸ’¡ Rule of thumb:** If the task takes >30 minutes or needs >2 subagents, consider optimization.

### Optimization Visibility Requirements
When using @prompting-expert, ensure complete transparency in the prompt log:

1. **Always log BOTH versions**: Original user prompt + optimized version
2. **Include analysis details**: Complexity assessment, model recommendation, cost estimates
3. **Document benefits achieved**: Token savings, execution improvements, time savings
4. **Track optimization ROI**: Compare actual vs. estimated benefits over time
5. **Tag optimized entries**: Use "(OPTIMIZED)" marker for easy identification

**Example Log Entry Workflow:**
```bash
# Step 1: User provides original prompt
"Build user authentication system with email/password, JWT tokens, and proper security"

# Step 2: Use prompting expert
cursor chat "@prompting-expert optimize this prompt..."

# Step 3: Log complete optimization trail in logs/prompts.md
# - Original prompt
# - Prompting expert analysis and recommendations  
# - Optimized prompt version
# - Expected vs actual benefits

# Step 4: Execute using optimized approach
```

## Advanced subagent patterns

### Subagent specialization for complex features

**E-commerce checkout flow**:
```bash
# Test Architect: Design comprehensive test strategy
cursor chat "@test-architect design test suite for e-commerce checkout flow including payment processing, inventory management, order confirmation, and error scenarios"

# Next.js Developer: Implement with Server Actions
cursor chat "@nextjs-dev implement checkout flow with Server Actions for payment processing, optimistic UI updates, and proper error boundaries"

# Security Auditor: Payment security review
cursor chat "@security-auditor audit payment processing implementation for PCI compliance, data encryption, and secure token handling"

# Performance Optimizer: Checkout performance
cursor chat "@performance-optimizer optimize checkout flow for Core Web Vitals, reduce bundle size, and implement efficient caching strategies"
```

**Real-time features with WebSockets**:
```bash
# Test Architect: Real-time testing strategy
cursor chat "@test-architect design testing approach for real-time chat feature including WebSocket connection testing, message delivery, and offline scenarios"

# Next.js Developer: WebSocket integration
cursor chat "@nextjs-dev implement real-time chat with WebSocket integration, Server Components for message history, and Client Components for live updates"

# Performance Optimizer: Real-time performance
cursor chat "@performance-optimizer optimize WebSocket performance, message batching, and memory management for real-time features"
```

### Subagent quality gates

**Automated quality validation**:
```javascript
// scripts/validate-subagent-standards.js
const validateSubagentStandards = {
  testArchitect: {
    coverageThreshold: 80,
    edgeCasesRequired: true,
    mockingStrategyDefined: true
  },
  
  nextjsDev: {
    typeScriptStrict: true,
    serverClientSeparation: true,
    errorBoundariesImplemented: true
  },
  
  securityAuditor: {
    inputValidationComplete: true,
    authenticationSecure: true,
    owaspCompliant: true
  },
  
  performanceOptimizer: {
    coreWebVitalsGood: true,
    bundleSizeUnder250KB: true,
    imagesToOptimized: true
  },
  
  codeReviewer: {
    cleanCodePrinciples: true,
    solidPrinciples: true,
    documentationComplete: true
  }
};
```

This comprehensive guide provides the foundation for building modern, maintainable Next.js applications using TDD principles enhanced with Claude Code subagent orchestration. The combination of rigorous testing discipline with specialized AI assistance creates a powerful development methodology optimized for 2025 and beyond, leveraging the full power of the Next.js ecosystem while ensuring security, performance, and code quality through dedicated subagent expertise.